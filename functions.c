#pragma config(Sensor, in1,    gyro,           sensorGyro)
#pragma config(Sensor, dgtl1,  encoderr,       sensorQuadEncoder)
#pragma config(Sensor, dgtl3,  encoderl,       sensorQuadEncoder)
#pragma config(Motor,  port1,           exr,          tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port2,           frontr,        tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port3,           backr,         tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port4,           frontl,        tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port5,           backl,         tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port6,           flyr,          tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port7,           flyl,          tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port8,           armt,          tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port9,           armb,          tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port10,           exl,          tmotorVex393_MC29, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

/**
 * @file functions.c
 * @brief This file contains all functions to be used by
 * the competition code.
 *
 * @warning DO NOT compile this file
 * by itself, it will not work. Instead, save it
 * and compile main.c
 *
 * Also, you must include your motor and sensor setup somewhere in this file.
 *
 * @author	 Sean Kelley      sgtkode01@gmail.com
 * @author   Bernard Suwirjo  bsuwirjo@gmail.com
 * @author	 Josh Asari				josh.asari@gmail.com
 *
 */

/////////////////////////////////////////////////////////////////////////////////////////
//
//                                 CONSTANTS
//
/////////////////////////////////////////////////////////////////////////////////////////

#define TIMEOUT_CNT_PER_SEC    10   /*!< amount of timeout counts per second */
#define MOTOR_SPEED        		 118  /*!< default motor speed */

int frontLeftVal  = 0; /*!< value of the front left  motor */
int backLeftVal   = 0; /*!< value of the back  left  motor */
int frontRightVal = 0; /*!< value of the front right motor */
int backRightVal  = 0; /*!< value of the back  right motor */


/////////////////////////////////////////////////////////////////////////////////////////
//
//                                 DRIVETRAIN
//
/////////////////////////////////////////////////////////////////////////////////////////

/**
* Clears all the motors
*
* @author  Bernard Suwirjo  bsuwirjo@gmail.com
* @author	 Sean Kelley      sgtkode01@gmail.com
*/
void clearMotors(){
	//Set all motor values to 0
	frontLeftVal  = 0;
	backLeftVal   = 0;
	frontRightVal = 0;
	backRightVal  = 0;
}

/**
* Sets all motors to a certain value
*
* @author Sean Kelley      sgtkode01@gmail.com
*
* @param  speed   the speed of the motors
*/
void setMotors(int speed){
	//Set all motor values to power value
	frontLeftVal  = speed;
	backLeftVal   = speed;
	frontRightVal = speed;
	backRightVal  = speed;
}

/**
* Sets the left motors to a given speed
*
* @author Spencer Couture  spence.couture@gmail.com
* @author Sean Kelley  sgtkode01@gmail.com
*
* @param  speed   the speed that the left motors will be set to
*
*/
void setMotorsLeft(int speed){
	frontLeftVal = speed;
	backLeftVal  = speed;
}

/**
* Sets the right motors to a given speed
*
* @author Spencer Couture  spence.couture@gmail.com
* @author Sean Kelley  sgtkode01@gmail.com
*
* @param  speed   the speed that the right motors will be set to
*
*/
void setMotorsRight(int speed){
	frontRightVal = speed;
	backRightVal  = speed;
}

/**
* Runs each motor for 1.5 seconds
*
* @author Bernard Suwirjo  bsuwirjo@gmail.com
*/
void testMotors()
{
	frontRightVal=118;//Set individual motor
	wait1Msec(1500); //Wait 1.5 seconds
	clearMotors(); //clear motor(s)
	backRightVal=118;
	wait1Msec(1500);
	clearMotors();
	frontLeftVal=118;
	wait1Msec(1500);
	clearMotors();
	backLeftVal=118;
	wait1Msec(1500);
	clearMotors();
}

/**
* Moves bot forward for a given amount of seconds
*
* @author Bernard Suwirjo  bsuwirjo@gmail.com
*
* @param  seconds  amount of seconds to move forward
*	@param  speed    speed of motors
*
*/
void forwardSeconds(float seconds, int speed=MOTOR_SPEED)
{
	//Set all motors to target value
	setMotors(speed);
	wait1Msec(seconds * 1000);//Wait given amount of time
	clearMotors();
}

/**
* Moves bot backward for a given amount of seconds
*
* @author Bernard Suwirjo  bsuwirjo@gmail.com
*
* @param  seconds  amount of seconds to move backward
*	@param  speed    speed of motors
*
*/
void backwardSeconds(float seconds, int speed=MOTOR_SPEED)
{
	//Set all motors to negative target value
	setMotors(-speed);
	wait1Msec(seconds * 1000);//Wait given amount of time
	clearMotors();
}

/**
* Drive until an encoder value is reached
*
* @author Sean Kelley		sgtkode01@gmail.com
*
* @param  encoder_count         encoder ticks to drive forward
*	@param  timeout_in_seconds    timeout for motors if encoder value is surpassed
* @param  speed									speed of motors
*
*/
int driveByEncoder( int encoder_count, int timeout_in_seconds = 5 , int speed=MOTOR_SPEED){
	int  timeout;

	// Drive motor until encoder has moved a number counts or
	// timeout_in_seconds seconds have passed

	// Zero the encoder
	SensorValue[ encoderr ] = 0;

	// Run the motor forwards or backwards
	if( encoder_count > 0 ){
		setMotors(speed);
	} else {
		setMotors(-speed);
	}

	// run loop until encoder hits encoder_count counts or timeout reached

	for( timeout=(timeout_in_seconds*TIMEOUT_CNT_PER_SEC); timeout > 0; timeout-- ){
		// check encoder
		if( encoder_count > 0 ){
			// going forwards
			if( SensorValue[ encoderr ] >= encoder_count ){
				break;
			} else {
			// going backwards
				if( SensorValue[ encoderr ] <= encoder_count ){
					break;
				}
			}
		}

		// wait 1/10 second
		wait1Msec( 100 );
	}

	// Stop the motor
	clearMotors();

	// See if we sucessfully found the right encoder value
	if( timeout <= 0 ){
		// there was an error - perhaps do something
		// return error
		return (-1);
	} else {
		// return success
		return 0;
	}
}

/**
*
* Locks left side motors with PI loop
*
* @warning function does not work
*
* @author Sean Kelley  sgtkode01@gmail.com
*
*/
task lockLeftSide()
{
	//float target = 0;
	//float pGain = .3;
	//float iGain = .02;
	//float error = target-SensorValue[encoderLeft];
	//float errorSum=0;
	while(true){
/*		error=target-SensorValue[encoderLeft];
		errorSum+=error;
		motor[FL] = error*pGain+errorSum*iGain;
		  motor[BL] = error*pGain+errorSum*iGain;*/
	}
}

/**
*
* Locks right side motors with PI loop
*
* @warning function does not work
*
* @author Sean Kelley  sgtkode01@gmail.com
*
*/
task lockRightSide()
{
	//float target = 0;
	//float pGain = .3;
	//float iGain = .02;
	//float error = target-SensorValue[encoderRight];
	//float errorSum=0;
	while(true){
	/*error=target-SensorValue[encoderRight];
		errorSum+=error;
		motor[FR] = error*pGain+errorSum*iGain;
	  motor[BR] = error*pGain+errorSum*iGain;*/
	}
}

/**
* Turns bot right only using left side motors
*
* @warning requires gyro
*
* @author Bernard Suwirjo  bsuwirjo@gmail.com
* @author Sean Kelley  sgtkode01@gmail.com
*
* @param   degrees   amount of degrees to turn right
* @param   forward   boolean if bot is turning forward or backward
* @param   speed     speed of motors
*
*/
void fancyTurnRightDegrees(int degrees, bool forward=true, int speed = MOTOR_SPEED){

	// reset encoders
	degrees=degrees*10;
	// reset gyro
	//gyro takes degrees from 0-3600, so we multiply by 10 to get a gyro processable number
	SensorValue[gyro]=0;
	// turn forwards or backwards based on forward boolean
	if(forward){
		while(abs(SensorValue[gyro]) < degrees){ //While the gyro value is less than the target perform code below
			//Set only the left side motors to the target value
			frontLeftVal = speed;
		  backLeftVal  = speed;
		}
		// stop motors
		clearMotors();
	} else {
		while(abs(SensorValue[gyro]) < degrees){
			//Set only the left side motors to the negative target value
			frontLeftVal = -speed;
		  backLeftVal  = -speed;
		}
		// stop motors
		clearMotors();
	}
}

/**
* Turns bot left only using left side motors
*
* @warning requires gyro
*
* @author Bernard Suwirjo  bsuwirjo@gmail.com
* @author Sean Kelley  sgtkode01@gmail.com
*
* @param   degrees   amount of degrees to turn left
* @param   forward   boolean if bot is turning forward or backward
* @param   speed     speed of motors
*
*/
void fancyTurnLeftDegrees(int degrees, bool forward=true, int speed = MOTOR_SPEED){
	// reset encoders
	degrees=degrees*10;
	// reset gyro
	//gyro takes degrees from 0-3600, so we multiply by 10 to get a gyro processable number
	SensorValue[gyro]=0;
	// turn forwards or backwards based on forward boolean
	if(forward){
		while(abs(SensorValue[gyro]) < degrees){ //While the gyro value is less than the target perform code below
			//Set only the left side motors to the target value
			frontRightVal = speed;
		  backRightVal  = speed;
		}
		// stop motors
		clearMotors();
	} else {
		while(abs(SensorValue[gyro]) < degrees){
			//Set only the left side motors to the negative target value
			frontRightVal = -speed;
		  backRightVal  = -speed;
		}
		// stop motors
		clearMotors();
	}
}

/**
* Turns bot right a given amount of degrees
*
* @warning requires gyro
*
* @author Bernard Suwirjo  bsuwirjo@gmail.com
* @author Sean Kelley  sgtkode01@gmail.com
*
* @param  degree  amount of degrees to turn right
*	@param	 speed       speed of motors
*
*/
void turnRightDegrees(float degree, float speed=90)
{
	//Reset gyro
	SensorValue[gyro]=0;
	//gyro takes degrees from 0-3600, so we multiply by 10 to get a gyro processable number
	degree=degree*10;
	//We want to slow down when we approach the target, so we calculate a first turn segment as 60% of the total
	float first=degree*.6;
	while(abs(SensorValue[gyro]) < first){ //Turn the first 60%
			//Since it's turn right, we want to set right motors backwards and left motors forward.
			frontLeftVal = speed;
    	frontRightVal = -speed;
    	backLeftVal = speed;
    	backRightVal = -speed;
	}
	while(abs(SensorValue[gyro]) <degree){ //Turn the remainin amount.
		//We don't want the motors to run too slow, so we set a a safety net. The motor can't have a power less than 40.
		if(speed*.35<40)//If 35% of the motor power is less than 40, set the power to 40.
		{
			frontLeftVal = 40;
    	frontRightVal = -40;
    	backLeftVal = 40;
    	backRightVal = -40;
		} else { //If not set it to 35%
				frontLeftVal = speed*.35;
	    	frontRightVal = -speed*.35;
	    	backLeftVal = speed*.35;
	    	backRightVal = -speed*.35;
    }
	}
	clearMotors();
}

/**
* Turns bot left a given amount of degrees
*
* @author Bernard Suwirjo  bsuwirjo@gmail.com
* @author Sean Kelley  sgtkode01@gmail.com
*
* @param  degree  amount of degrees to turn left
*	@param	speed   speed of motors
*
*/
void turnLeftDegrees(float degree, float speed=90)
{
	//Reset gyro
	SensorValue[gyro]=0;
	//gyro takes degrees from 0-3600, so we multiply by 10 to get a gyro processable number
	degree=degree*10;
	//We want to slow down when we approach the target, so we calculate a first turn segment as 60% of the total
	float first=degree*.6;
	while(abs(SensorValue[gyro]) < first){
			//Since it's turn left, we want to set right motors forwards and left motors backwards.
				frontLeftVal = -speed;
  	    frontRightVal = speed;
  	    backLeftVal = -speed;
  	    backRightVal = speed;
	}
	while(abs(SensorValue[gyro]) < degree){
		//We don't want the motors to run too slow, so we set a a safety net. The motor can't have a power less than 40.
		if(speed*.35<40)//If 35% of the motor power is less than 40, set the power to 40.
		{
				frontLeftVal = -40;
		    frontRightVal = 40;
		    backLeftVal = -40;
		    backRightVal = 40;
		} else { //If not set it to 35%
				frontLeftVal = -speed*.35;
  	    frontRightVal = speed*.35;
  	    backLeftVal = -speed*.35;
  	    backRightVal = speed*.35;
    }
	}
	clearMotors();
}


/**
* Turns bot right a given amount of seconds
*
* @author Bernard Suwirjo  bsuwirjo@gmail.com
*
* @param   seconds   amount of seconds to turn right
* @param	 speed     speed of motors
*
*/
void turnRightSeconds(float seconds, float speed=118)
{
	//Since turn right, we want to set left motors forwards and right motors backwards.
	frontLeftVal=speed;
	backLeftVal=speed;
	frontRightVal=-speed;
	backRightVal=-speed;
	wait1Msec(seconds*1000); //Wait desired amount of time
	clearMotors(); //Stop
}

/**
* Turns bot left a given amount of seconds
*
* @author Bernard Suwirjo  bsuwirjo@gmail.com
*
* @param  seconds   amount of seconds to turn left
* @param	speed    speed of motors
*
*/
void turnLeftSeconds(float seconds, float speed=118)
{
	//Since turn left, we want to set the right motors forward and the left motors backwards
	frontLeftVal = -speed;
	backLeftVal = -speed;
	frontRightVal = speed;
	backRightVal = speed;
	wait1Msec(seconds*1000); //Wait desired amount of time
	clearMotors(); //Stop
}

/**
*	Set the motors to the current values
*
* @author Sean Kelley  sgtkode01@gmail.com
*
*/

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


/**
* Drives the bot forward a given amount of seconds
*
* @author Marc Reardon  marcdreardon@gmail.com
*
* @param  secs     amount of seconds to go forward
* @param	speed    speed of motors
*
*/
void auto_drive_forward(float speed, float secs){
	motor[frontl] = -speed;
	motor[frontr] = speed;
	motor[backl] = -speed;
	motor[backr] = speed;
	wait1Msec(secs*1000);
	motor[frontl] = 0;
	motor[frontr] = 0;
	motor[backl] = 0;
	motor[backr] = 0;

}

/**
* Spins the flywheel by acceleration
*
* @author Marc Reardon  marcdreardon@gmail.com
*
* @param  f   final speed for the motors to run at
*
*/
void spin_flywheel(float f){
	int speed = 0;
	//if the motors are not already running
	if (motor[flyr] == 0 && motor[flyl] == 0 && motor[exr] == 0 && motor[exl] == 0){
		//while the actual speed is less than the final speed
		while (speed < f){
			motor[flyr] = speed;
			motor[flyl] = -speed;
			motor[exr] = -speed;
			motor[exl] = speed;
			speed = speed + 10;    //increase the motor speed
			wait1Msec(300);
			if (speed >= f){
				motor[flyr] = f;
				motor[flyl] = -f;
				motor[exr] = -f;
				motor[exl] = f;
			}
		}

	}
}


/**
* Spins the flywheel by acceleration, then continues for a given amount of seconds
*
* @author Marc Reardon  marcdreardon@gmail.com
*
* @param  seconds   amount of seconds to continue at final speed
* @param	f         final speed for the motors to run at
* @param  doStop    if want it to stop after the given amount of seconds
*
*/
void auto_spin_flywheel(float f, float seconds, bool doStop){
	int speed = 0;

	//while the actual speed is less than the final speed
	while (speed < f){
		motor[flyr] = speed;
		motor[flyl] = -speed;
		motor[exr] = -speed;
		motor[exl] = speed;
		speed = speed + 10;    //increase the motor speed
		wait1Msec(300);
		if (speed >= f){
			motor[flyr] = f;
			motor[flyl] = -f;
			motor[exr] = -f;
			motor[exl] = f;
		}
	}

	motor[armt] = -100;
	motor[armb] = -100;

	//if you want to stop after a given amount of time
	if (doStop){
		wait1Msec(seconds*1000);
		motor[flyr] = 0;
		motor[flyl] = 0;
		motor[exr] = 0;
		motor[exl] = 0;
		motor[armt] = 0;
		motor[armb] = 0;
	}
}

/**
* Turns the intake a given amount of seconds
*
* @author Marc Reardon  marcdreardon@gmail.com
*
* @param  seconds   amount of seconds to spin for
* @param	speed     speed of motors
*
*/
void auto_intake_balls(float speed, float seconds){
	motor[armt] = -speed;
	motor[armb] = -speed;
	wait1Msec(seconds*1000);
	motor[armt] = 0;
	motor[armb] = 0;
}


////////////////////////////////////////////////////////////////////////////////
//
//									USERCONTROL TASKS
//
////////////////////////////////////////////////////////////////////////////////


/**
* Uses one button to toggle on/off for intake
*
* @author Marc Reardon  marcdreardon@gmail.com
*
*/
task intake(){
	bool unpressed = false;

	while(true){
		if(bVEXNETActive){

			//defaults to this
			//if the button has been unpressed from after turning the motors off
			if(unpressed == false){
				if(vexRT[Btn7D] == 1){
					motor[armt] = -75;
					motor[armb] = -75;
					while(vexRT[Btn7D] == 1){
						wait1Msec(1);
					}
					if(vexRT[Btn7D] == 0){
						unpressed = true;
					}
				}

			}

			//if the button has been unpressed from after turning the motors on
			if(unpressed == true){
				if(vexRT[Btn7D] == 1){
					motor[armt] = 0;
					motor[armb] = 0;
					while(vexRT[Btn7D] == 1){
						wait1Msec(1);
					}
					if(vexRT[Btn7D] == 0){
						unpressed = false;

					}
				}

			}

			//so this loop doesn't hog the cpu
			wait1Msec(10);

		}
	}

}


/**
* Uses one button to toggle on/off for flywheel
* Uses three buttons to change speed modes
*
* @author Marc Reardon  marcdreardon@gmail.com
*
*/
task flywheel(){
	bool unpressed = false;
	int speed_select = 118;
	bool selpressed = false;

	while(true){
		if(bVEXNETActive){

			/*///////////////////////////////////////////// THIS
			if(motor[flyr] > 0 && motor[flyl] < 0){

				while(speed_select == 118){
					if(vexRT[Btn8R] == 1){
						speed_select = speed_select - 10;
					}
					wait1Msec(5);
				}

				motor[flyr] = speed_select;
				motor[flyl] = -speed_select;

				while(speed_select < 118 && speed_select >= 0){
					if(vexRT[Btn8R] == 1){
						speed_select = speed_select - 10;
					}
					if(vexRT[Btn8L] == 1){
						speed_select = speed_select + 10;
					}
					wait1Msec(5);
				}

				motor[flyr] = speed_select;
				motor[flyl] = -speed_select;

			}
			*/


			/*/////////////////////////////////////////// OR THIS
			//change speed
			if(vexRT[Btn8L] == 1){
				speed_select = 50;
			}
			//change speed
			if(vexRT[Btn8U] == 1){
				speed_select = 75;
			}
			//change speed
			if(vexRT[Btn8R] == 1){
				speed_select = 118;
			}

			//check to see if the user changed the speed
			if(motor[flyr] > 0 && motor[flyl] < 0){
				motor[flyr] = speed_select;
				motor[flyl] = -speed_select;
				motor[exr] = -speed_select;
				motor[exl] = speed_select;
				wait1Msec(1);
			}
			*/


			//defaults: speed_select = 118 && unpressed = false
			//if the button has been unpressed from after turning the motors off
			if(unpressed == false){
				if(vexRT[Btn8D] == 1){
					spin_flywheel(speed_select);
					while(vexRT[Btn8D] == 1){
						wait1Msec(1);
					}
					if(vexRT[Btn8D] == 0){
						unpressed = true;

					}
				}

			}

			//if the button has been unpressed from after turning the motors on
			if(unpressed == true){
				if(vexRT[Btn8D] == 1){
					motor[flyr] = 0;
					motor[flyl] = 0;
					motor[exr] = 0;
					motor[exl] = 0;
					while(vexRT[Btn8D] == 1){
						wait1Msec(1);
					}
					if(vexRT[Btn8D] == 0){
						unpressed = false;

					}
				}

			}

			//so this loop doesn't hog the cpu
			wait1Msec(10);
		}

	}

}

/**
* Uses two different buttons to switch on/off reverse drive
*
* @author Marc Reardon  marcdreardon@gmail.com
*
*/
task drive(){
	bool initial = true;

	while(true){
		if(bVEXNETActive){

			while(initial == true){
				//sets drive to a regular state
				motor[backr] = vexRT[Ch2];
				motor[frontr] = vexRT[Ch2];
				motor[backl] = -vexRT[Ch3];
				motor[frontl] = -vexRT[Ch3];
				if (vexRT[Btn5U] == 1){
					initial = false;

				}

			}

			while(initial == false){
				//sets the drive to reverse
				motor[backr] = -vexRT[Ch3];
				motor[frontr] = -vexRT[Ch3];
				motor[backl] = vexRT[Ch2];
				motor[frontl] = vexRT[Ch2];
				if(vexRT[Btn6U] == 1){
					initial = true;
				}

			}

		//so this loop doesn't hog the cpu
		wait1Msec(10);

		}
	}

}


////////////////////////////////////////////////////////////////////////////////
//
//									AUTONOMOUS TASKS
//
////////////////////////////////////////////////////////////////////////////////

//will be implemented in later competitions
/*
task auto_intake(){

}
*/

//will be implemented in later competitions
/*
task auto_flywheel(){

		//spin the flywheel and lift balls for the length of autonomous
		auto_spin_flywheel(118,15,true);

}
*/

//will be implemented in later competitions
/*
task auto_drive(){

		//auto_drive_forward(100,3);

}
*/
